// Generated by CoffeeScript 1.6.3
(function() {
  var BLACKLIST, CDNJS_ROOT, START_FROM_SCRATCH, async, createFileMap, errors, filesDontMatch, fs, glob, npm, npmNotFound, path, request, tarball, upToDate, updatePackages, updated, verifyFilesExist, writeNpmMap, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  async = require('async');

  fs = require('fs-extra');

  glob = require('glob');

  path = require('path');

  npm = require('npm');

  tarball = require('tarball-extract');

  request = require('request');

  CDNJS_ROOT = '/Users/misha/Projects/github/cdnjs/ajax/libs/';

  START_FROM_SCRATCH = true;

  BLACKLIST = ['noisy'];

  updated = [];

  errors = [];

  npmNotFound = [];

  filesDontMatch = [];

  upToDate = [];

  if (START_FROM_SCRATCH && fs.existsSync(path.join(__dirname, 'temp'))) {
    fs.removeSync(path.join(__dirname, 'temp'));
  }

  RegExp.escape = function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  };

  writeNpmMap = function(obj, cb) {
    var json;
    json = fs.readJSONFileSync(obj["package"]);
    json.npmName = obj.name;
    json.npmFileMap = [
      {
        "basePath": "/",
        "files": obj.files
      }
    ];
    fs.writeJSONFileSync(obj["package"], json);
    console.log("Added npmFileMap to: " + obj.name);
    updated.push(obj);
    return cb();
  };

  verifyFilesExist = function(obj, cb) {
    var foundFiles, notFound, unpackedFiles;
    notFound = [];
    foundFiles = [];
    unpackedFiles = glob.sync(obj.unpacked + "/**/*.*");
    _.each(obj.files, function(f) {
      var found;
      found = _.find(unpackedFiles, function(uf) {
        var fname;
        fname = path.basename(uf);
        return fname === path.basename(f);
      });
      if (found) {
        return foundFiles.push(path.relative(obj.unpacked, found));
      } else {
        return notFound.push(f);
      }
    });
    if (notFound.length === 0) {
      console.log("All files in [" + obj.name + "] exist in npm!");
      obj.files = foundFiles;
      return writeNpmMap(obj, cb);
    } else {
      console.log(("Couldnt find all files in [" + obj.name + "] - missing: ") + notFound.join(', '));
      filesDontMatch.push(obj);
      return cb();
    }
  };

  createFileMap = function(obj, cb) {
    var dest, done, s, tempFile, tmp;
    tmp = path.join(__dirname, 'temp', obj.name);
    tempFile = path.join(tmp, obj.name + '.tgz');
    dest = path.join(tmp, obj.ver);
    done = function() {
      obj.unpacked = path.join(dest, 'package');
      return verifyFilesExist(obj, cb);
    };
    if (fs.existsSync(dest)) {
      return done();
    } else {
      fs.mkdirsSync(dest);
      s = request.get({
        url: obj.tarball
      });
      s.pipe(fs.createWriteStream(tempFile));
      return s.on('end', function() {
        return tarball.extractTarball(tempFile, dest, function(err) {
          if (err) {
            errors.push(obj);
            return cb();
          } else {
            return done();
          }
        });
      });
    }
  };

  updatePackages = function(cb) {
    return npm.load(npm.config, function(err) {
      var packages;
      packages = glob.sync(CDNJS_ROOT + "*/package.json");
      return async.eachSeries(packages, function(pkg, cb) {
        var name, p, ver;
        p = fs.readJsonFileSync(pkg);
        name = p.name;
        ver = p.version;
        if (!p.npmFileMap && __indexOf.call(BLACKLIST, name) < 0) {
          console.log('npm view', name + "@" + ver);
          return npm.commands.view([name + "@" + ver], function(err, result) {
            var files, found, libpath, match;
            if (result) {
              match = result[ver];
              if (match) {
                libpath = path.join(path.dirname(pkg), ver);
                files = _.map(glob.sync(libpath + "/**/*.*"), function(f) {
                  return path.relative(libpath, f);
                });
                found = {
                  tarball: match.dist.tarball,
                  files: files,
                  "package": pkg,
                  name: name,
                  ver: ver
                };
                return createFileMap(found, cb);
              }
            }
            console.log('npm not found: ', name);
            npmNotFound.push(name);
            return cb();
          });
        } else {
          upToDate.push(name);
          return cb();
        }
      }, function(err) {
        return cb();
      });
    });
  };

  updatePackages(function() {
    console.log('package scan done:');
    console.log('------------------');
    console.log('updated:', updated.length);
    console.log(_.map(updated, function(o) {
      return o.name;
    }));
    console.log('npmNotFound:', npmNotFound.length);
    console.log(_.map(npmNotFound, function(o) {
      return o.name;
    }));
    console.log('filesDontMatch:', filesDontMatch.length);
    console.log(_.map(filesDontMatch, function(o) {
      return o.name;
    }));
    console.log('upToDate:', upToDate.length);
    console.log(upToDate);
    console.log('errors:', errors.length);
    return console.log(errors);
  });

}).call(this);

/*
//@ sourceMappingURL=app.map
*/
