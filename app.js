// Generated by CoffeeScript 1.6.3
(function() {
  var ALLOW_MISSING_MINJS, BLACKLIST, CDNJS_ROOT, CHECK_MD5, START_FROM_SCRATCH, async, compareFiles, config, createFileMap, crypto, errors, filesDontMatch, fs, glob, logFile, logger, md5DontMatch, npm, npmNotFound, path, request, tarball, upToDate, updatePackages, updated, verifyFilesExist, winston, writeNpmMap, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  async = require('async');

  fs = require('fs-extra');

  glob = require('glob');

  path = require('path');

  npm = require('npm');

  tarball = require('tarball-extract');

  request = require('request');

  crypto = require('crypto');

  winston = require('winston');

  logFile = path.join(__dirname, 'convert.log');

  if (fs.existsSync(logFile)) {
    fs.removeSync(logFile);
  }

  logger = new winston.Logger({
    transports: [
      new winston.transports.Console(), new winston.transports.File({
        filename: logFile,
        json: false
      })
    ]
  });

  config = require("./config.json");

  CDNJS_ROOT = config.root;

  START_FROM_SCRATCH = config.cleanStart;

  BLACKLIST = config.blacklist;

  ALLOW_MISSING_MINJS = config.allowMissingMinJS;

  CHECK_MD5 = config.checkMD5;

  updated = [];

  errors = [];

  npmNotFound = [];

  filesDontMatch = [];

  md5DontMatch = [];

  upToDate = [];

  if (START_FROM_SCRATCH && fs.existsSync(path.join(__dirname, 'temp'))) {
    fs.removeSync(path.join(__dirname, 'temp'));
  }

  RegExp.escape = function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  };

  compareFiles = function(f1, f2, cb) {
    var hash;
    if (!f1 || !f2) {
      return cb(true);
    }
    hash = function(file) {
      return function(cb) {
        var md5sum, s;
        if (!CHECK_MD5) {
          return cb(null, "not checking md5");
        }
        md5sum = crypto.createHash('md5');
        s = fs.ReadStream(file);
        s.on('data', function(d) {
          return md5sum.update(d);
        });
        return s.on('end', function(d) {
          return cb(null, md5sum.digest('hex'));
        });
      };
    };
    return async.parallel([hash(f1), hash(f2)], function(err, hashes) {
      return cb(err, hashes[0] === hashes[1], hashes[0], hashes[1]);
    });
  };

  writeNpmMap = function(obj, cb) {
    var json;
    if (obj.files.length === 0) {
      logger.warn("wanted to write an npm map for " + obj.name + " with 0 files. This is a bug!");
      return cb();
    }
    json = fs.readJSONFileSync(obj["package"]);
    json.npmName = obj.name;
    json.npmFileMap = [
      {
        "basePath": "/",
        "files": obj.files
      }
    ];
    fs.writeJSONFileSync(obj["package"], json);
    logger.info("Added npmFileMap to: " + obj.name);
    updated.push(obj);
    return cb();
  };

  verifyFilesExist = function(obj, cb) {
    var badMD5, findFileInNpm, foundFiles, noCompare, notFound, unpackedFiles;
    notFound = [];
    badMD5 = [];
    foundFiles = [];
    logger.info("Verifing that all files exist in [" + obj.name + "] ...");
    unpackedFiles = glob.sync(obj.unpacked + "/**/*.*");
    findFileInNpm = function(f) {
      var found;
      found = _.find(unpackedFiles, function(uf) {
        var upath;
        upath = path.relative(obj.unpacked, uf);
        return upath === f;
      });
      return found || _.find(unpackedFiles, function(uf) {
        var fbase, ubase;
        ubase = path.basename(uf);
        fbase = path.basename(f);
        return ubase === fbase;
      });
    };
    noCompare = function(f1, f2, cb) {
      return cb(!f1 || !f2, true);
    };
    return async.eachLimit(obj.files, 10, function(f, cb) {
      var cdnFile, compareFn, found, origFile;
      found = findFileInNpm(f);
      compareFn = compareFiles;
      if (!found && ALLOW_MISSING_MINJS) {
        origFile = f.replace(".min.js", ".js");
        found = findFileInNpm(origFile);
        compareFn = noCompare;
      }
      cdnFile = path.join(obj.path, f);
      return compareFn(found, cdnFile, function(err, match, h1, h2) {
        if (err) {
          notFound.push(f);
        } else if (match) {
          foundFiles.push(path.relative(obj.unpacked, found));
        } else {
          logger.info("[" + obj.name + "] md5 does not match: ", found, cdnFile, h1, h2);
          badMD5.push(f);
        }
        return cb();
      });
    }, function(err) {
      if (notFound.length === 0 && badMD5.length === 0) {
        logger.info("All files in [" + obj.name + "] exist in npm!");
        obj.files = _.uniq(foundFiles);
        return writeNpmMap(obj, cb);
      } else {
        logger.info("Couldnt find all files in [" + obj.name + "]:");
        if (notFound.length) {
          logger.info("   Missing: " + notFound.join(', '));
          filesDontMatch.push(obj);
        }
        if (badMD5.length) {
          logger.info("   Bad MD5: " + badMD5.join(', '));
          md5DontMatch.push(obj);
        }
        return cb();
      }
    });
  };

  createFileMap = function(obj, cb) {
    var dest, done, s, tempFile, tmp;
    tmp = path.join(__dirname, 'temp', obj.name);
    tempFile = path.join(tmp, obj.name + '.tgz');
    dest = path.join(tmp, obj.ver);
    done = function() {
      obj.unpacked = path.join(dest, 'package');
      return verifyFilesExist(obj, cb);
    };
    if (fs.existsSync(dest)) {
      return done();
    } else {
      fs.mkdirsSync(dest);
      s = request.get({
        url: obj.tarball
      });
      s.pipe(fs.createWriteStream(tempFile));
      return s.on('end', function() {
        return tarball.extractTarball(tempFile, dest, function(err) {
          if (err) {
            errors.push(obj);
            return cb();
          } else {
            return done();
          }
        });
      });
    }
  };

  updatePackages = function(cb) {
    return npm.load(npm.config, function(err) {
      var packages;
      packages = glob.sync(CDNJS_ROOT + "*/package.json");
      return async.eachSeries(packages, function(pkg, cb) {
        var name, p, ver;
        p = fs.readJsonFileSync(pkg);
        name = p.name;
        ver = p.version;
        if (!p.npmFileMap && __indexOf.call(BLACKLIST, name) < 0) {
          return npm.commands.view([name + "@" + ver], function(err, result) {
            var files, found, libpath, match;
            if (result) {
              match = result[ver];
              if (match) {
                libpath = path.join(path.dirname(pkg), ver);
                files = _.map(glob.sync(libpath + "/**/*.*"), function(f) {
                  return path.relative(libpath, f);
                });
                found = {
                  tarball: match.dist.tarball,
                  files: files,
                  "package": pkg,
                  name: name,
                  path: libpath,
                  ver: ver
                };
                return createFileMap(found, cb);
              }
            }
            npmNotFound.push(name);
            return cb();
          });
        } else {
          upToDate.push(name);
          return cb();
        }
      }, function(err) {
        return cb();
      });
    });
  };

  updatePackages(function() {
    logger.info('package scan done:');
    logger.info('------------------');
    logger.info('updated:', updated.length);
    if (updated.length) {
      logger.info("     " + _.map(updated, function(o) {
        return o.name;
      }).join(", "));
    }
    logger.info('npm not found:', npmNotFound.length);
    if (npmNotFound.length) {
      logger.info("     " + npmNotFound.join(", "));
    }
    logger.info('not all files in npm:', filesDontMatch.length);
    if (filesDontMatch.length) {
      logger.info("     " + _.map(filesDontMatch, function(o) {
        return o.name;
      }).join(", "));
    }
    logger.info('MD5 mismatch:', md5DontMatch.length);
    if (md5DontMatch.length) {
      logger.info("     " + _.map(md5DontMatch, function(o) {
        return o.name;
      }).join(", "));
    }
    logger.info('already converted:', upToDate.length);
    if (upToDate.length) {
      logger.info("     " + upToDate.join(", "));
    }
    logger.info('errors:', errors.length);
    if (errors.length) {
      logger.info("     " + errors.join(", "));
    }
    return console.log("See convert.log for full log");
  });

}).call(this);

/*
//@ sourceMappingURL=app.map
*/
